# README

Replication of results presented in:
"Adjoint optimization of pressurized membrane structures using automatic differentiation tools"

## REPLICATION OF RESULTS
You must have dolfin-adjoint with FEniCS and IPOPT installed:
The easiest way is to use Docker (or Singularity on a research cluster)
See http://www.dolfin-adjoint.org/en/latest/download/index.html for detailed instructions

and also 
https://fenics.readthedocs.io/projects/containers/en/latest/introduction.html

To generate the plots, you will need to have installed matplotlib and pandas 

Some visualizations were made externally using Paraview 
www.paraview.org

## Quickstart

You will need Docker installed on your machine to continue.

First, clone the repo:
`git clone https://github.com/oaniewiarowski/FenicsMembranesCMAME.git`

`cd FenicsMembranesCMAME`

Then start a Docker session with access to current folder:

`docker run -ti -v $(pwd):/home/fenics/shared quay.io/dolfinadjoint/pyadjoint`

Enter the repo:

`cd shared`

Install the membrane library (use `-e` (editable) flag if you want to make any changes):

`pip3 install --user  -e .`

We also need these dependencies:
`pip3 install --user matplotlib`
`pip3 install --user pandas`

The examples are in the following directory:

`cd CMAME/examples`

Run a problem:

`python3 main_results.py p1`

then plot the results:

`python3 main_results.py p1 --plot`

The plots are saved in `submission/`. FYI: The first time runnning the code will take significantly longer becuase of one-time compilation.

## Special instructions for Singularity
The code can also be run on a research cluster with resource management ie SLURM
using Singularity. To convert the docker image to singularity:

`singularity pull docker://quay.io/dolfinadjoint/pyadjoint:2019.1.0`

Then you can start a singularity shell:
`singularity shell pyadjoint_2019.1.0.sif`

Singularity automatically exposes the host environment (unlike docker). 
Next, while in the singularity shell, install the dependencies as indicated above.
`Singularity> pip3 install --user -e .`

To run batch jobs, exit the container (`exit`), and run the python script `main_results.py`  (the autogenerated slurm script will launch the container) :

`python3 main_results.py p1 --slurm`

Note: you must configure the slurm script generator settings at the top of `main_results.py` with your email, time required etc.

To run all the examples at once:
`python3 main_results.py all --slurm`

To plot, launch the singularity shell again. 
`singularity shell ../../../pyadjoint_2019.1.0.sif `
`Singularity> python3 main_results.py p1 --plot`
## Details

The problem data from the paper are configured in the convenience script: `main_results.py`.

The script is called from the command line with a command corresponding to the problem ie
` python3 main_results.py p1`

The above command will recreate the results for the plane strain 
pressure minimization problem (Problem 1). 

If running on a cluster, this script will automatically create and submit slurm scripts. If so,
the `path_to_sif` variable in 'main_results.py' may need to be edited to provide the correct path to the `.sif` file
 
If running on a personal machine, stdout is redirected to the output file specified by the `--path` variable

Once the optimization terminates, the results can be plotted:

` python3 main_results.py p1 --plot`

Problems 1 and 2A have the option to also calculate and save the gradient for the chosen control bounds.

` python3 main_results.py p1a --deriv`

To run the Taylor tests:
` python3 main_results.py p1 --tt`

To disable optimization (if you only want to run the taylor test and/or gradient study):

` python3 main_results.py p1 --tt --deriv --no-optimize `
` python3 main_results.py p1 --tt --no-optimize `

See `--help` for more choices.

For convenience the main results can be replicated with one command:
` python3 main_results.py all `
    
To experiment with the code, you can also pass other args to the individual problem scripts directly:
`python3 problem1.py [<options>]`

See each problem for details.

## Note on runtimes
As currently configured, problem P1 (pressure optimization) and problem 3A (plane strain thickness optimization) each take ~<10 min to run. Each shape optimization (P2 A and B) take about 30 min each. 3D thickness optimization takes about an hour (as it is the largest problem). You can reduce the mesh resolution in the `main_results.py` to reduce the runtimes, but results may vary/are not guaranteed. You can inspect the stdout (redirected to file specified in path) to monitor the progress. 


